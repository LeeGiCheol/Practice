/*
 
	아래 그럼처럼 높이만 다르고 (같은 높이의 막대기가 있을 수 있음) 모양이 같은 막대기를 일렬로 세운 후, 
	
	왼쪽부터 차례로 번호를 붙이다.
	
	각 막대기의 높이는 그림에서 보인 것처럼 순서대로 6,9,7,6,4,6 이다. 
	
	일렬로 세워진 막대기를 오른쪽에서 보면 보이는 막대기가 있고 보이지 않는 막대기가 있다. 
	
	즉, 지금 보이는 막대기보다 뒤에 있고 높이가 높은 것이 보이게 된다. 
	
	예를 들어, 그림과 같은 경우엔 3개(6번,3번,2번)의 막대기가 보인다.
	
	N개의 막대기에 대한 높이 정보가 주어질 때, 
	
	오른쪽에서 보아서 몇 개가 보이는지를 알아내는 프로그램을 작성하려고 한다.
	
	표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 막대기의 개수를 나타내는 정수 N(2≤N≤100,000)이 주어지고 이어지는 N줄 각각엔 막대기의 높이를 나타내는 정수 h(1≤h≤100,000)가 주어진다.
	
	 
	출력형식
	표준 출력으로 오른쪽에서 N개의 막대기를 보았을 때, 보이는 막대기의 개수를 출력한다. 채점 기준 제출된 프로그램은 여러 개의 테스트 케이스로 평가되며, 맞은 테스트 케이스에 대해서 해당 테스트 케이스에 배정된 점수를 받는다. 모든 테스트 케이스를 맞았을 시 100점을 받는다. 각 테스트 케이스에 대한 배점 정보와, 제약 조건은 다음과 같다.
	그룹1, 총 12점 상당의 테스트 케이스로 구성되어 있다. 각각 N≤5, h≤2를 만족한다.
	그룹2, 총 15점 상당의 테스트 케이스로 구성되어 있다. 각각 N≤5를 만족한다.
	그룹3, 총 36점 상당의 테스트 케이스로 구성되어 있다. 각각 N≤1,000을 만족한다.
	그룹4, 총 37점 상당의 테스트 케이스로 구성되어 있다. 추가적인 제약 조건이 없다.
	
	http://www.jungol.co.kr/bbs/board.php?bo_table=pbank&wr_id=2626
	
	
	
	--- 풀이 ---
	KOI 초등학교 문제라해서 풀어보게 되었다.
	크기가 다른 막대기를 우측에서 봤을때 볼 수 있는 막대기 개수를 찾아내는 문제였다.
	
	간단하게 배열에 막대기 크기를 담고
	temp 변수에 가장 끝 (제일 우측)에 있는 값을 담았다.
	
	그리고 temp와 그 전값을 비교하면서
	전값이 더 크다면 temp에 담고 카운팅하는 방식으로 풀이했다.
	
	점수는 100점으로 나왔다.
	
 */

package algorithm;

import java.util.Scanner;

public class Bar {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		// 테스트 케이스
		int TC = sc.nextInt();
		
		int[] arr = new int[TC];
		// 첫번째 막대는 무조건 보이니까 1
		int cnt = 1;
		
		for (int i = 0; i < TC; i++) {
			arr[i] = sc.nextInt();
		}
		
		// 값을 비교해 큰 값을 담아둘 변수 (맨뒷값)
		int temp = arr[TC - 1];
		
		// 맨뒷값과 그 전값을 비교해 큰 값을 temp에 저장 후 counting
		for (int i = 0; i < TC; i++) {
			if(temp < arr[TC - i - 1]) {
				temp = arr[TC - i - 1];
				cnt++;
			}
		}
		
		System.out.println(cnt);
	}
}
